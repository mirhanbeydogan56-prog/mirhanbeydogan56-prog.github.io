<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake.io — Gelişmiş (Bots, Skins, Patlama, Joystick, MiniMap)</title>
  <style>
    :root{--bg:#05080f}
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,Arial,Helvetica,sans-serif}
    canvas{display:block}
    .ui{position:fixed;right:16px;top:16px;z-index:999;color:#dbeafe}
    .ui button{background:#0b1220;border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:#fff;margin-left:8px}
    #skins{position:fixed;left:16px;top:16px;z-index:999;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px}
    #skins input[type=color]{width:40px;height:34px;border:0;padding:0}
    #joystick{position:fixed;left:18px;bottom:18px;width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;touch-action:none}
    #stick{width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.08);transition:transform 0.02s}
    #minimap{position:fixed;right:16px;bottom:16px;border-radius:50%;border:2px solid rgba(255,255,255,0.06);background:#041226;z-index:999;overflow:hidden}
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div class="ui"><button id="btnNew">Yeni Oyun</button><button id="btnPause">Duraklat</button><span id="scoreUI" style="margin-left:12px">Skor: 0</span></div>
<div id="skins">
  <div style="margin-bottom:8px">Skin: <input id="colorPicker" type="color" value="#34d399"></div>
  <div>Kalınlık: <input id="thickness" type="range" min="8" max="24" value="14"></div>
</div>
<div id="joystick"><div id="stick"></div></div>
<canvas id="minimap" width="160" height="160" style="border-radius:50%"></canvas>

<script>
// Fixed and cleaned game file
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');
mini.width = 160; mini.height = 160; // smaller circular minimap
let W = 0, H = 0;
function resize(){ W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize(); window.addEventListener('resize', resize);

// World
const WORLD_SIZE = 4000;

// Helpers
const rand = (a,b)=>Math.random()*(b-a)+a;
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
function hslToRgb(h,s,l){ s/=100; l/=100; const k=n=> (n + h/30) % 12; const a=s*Math.min(l,1-l); const f=n=> l - a*Math.max(-1,Math.min(Math.min(k(n)-3,9-k(n)),1)); return [Math.round(255*f(0)),Math.round(255*f(8)),Math.round(255*f(4))]; }

// Bot names pool
const botNames = ["Luna","Mira","Kora","Zeno","Pyra","Vex","Rika","Nova","Flux","Zara","Maly","Retiy","Sorin","Tila","Jaxu"];

// Make snake
function makeSnake(isBot=false){
  const h = rand(0,360); const rgb = hslToRgb(h,80,60);
  const name = isBot ? botNames[Math.floor(Math.random()*botNames.length)] : 'Esma';
  return {
    x: rand(-WORLD_SIZE/2, WORLD_SIZE/2),
    y: rand(-WORLD_SIZE/2, WORLD_SIZE/2),
    dir: rand(0, Math.PI*2),
    speed: 2.6,
    len: 60,
    tail: [],
    color: rgb,
    thickness: 14,
    isBot: !!isBot,
    alive: true,
    score: 0,
    name: name,
    respawnTimer: 0
  };
}

let player = makeSnake(false);
player.color = [52,211,153]; player.thickness = 14; player.name = 'Esma';
let snakes = [player];
for(let i=0;i<8;i++) snakes.push(makeSnake(true));

// Food
let foods = [];
function spawnFood(){ const h=rand(0,360); const rgb=hslToRgb(h,80,60); foods.push({ x:rand(-WORLD_SIZE/2,WORLD_SIZE/2), y:rand(-WORLD_SIZE/2,WORLD_SIZE/2), r:7, color:rgb }); }
for(let i=0;i<120;i++) spawnFood();

// Particles
let particles = [];
function spawnExplosion(x,y,color,amount=30){ for(let i=0;i<amount;i++){ particles.push({ x,y, vx:rand(-200,200), vy:rand(-200,200), t:0, life:rand(0.6,1.4), color }); } }

// Camera
let cam = { x: player.x - W/2, y: player.y - H/2 };
function updateCamera(){ cam.x += (player.x - W/2 - cam.x) * 0.18; cam.y += (player.y - H/2 - cam.y) * 0.18; }

// Controls
let pointer = { x:0, y:0, active:false };
window.addEventListener('mousemove', e=>{ pointer.x = e.clientX; pointer.y = e.clientY; });
window.addEventListener('mousedown', ()=> pointer.active = true);
window.addEventListener('mouseup', ()=> pointer.active = false);

// Joystick
const stickWrap = document.getElementById('joystick');
const stick = document.getElementById('stick');
let joy = { active:false, cx:0, cy:0, dx:0, dy:0 };
function updateJoyPos(){ const r = stickWrap.getBoundingClientRect(); joy.cx = r.left + r.width/2; joy.cy = r.top + r.height/2; }
updateJoyPos(); window.addEventListener('resize', updateJoyPos);
stickWrap.addEventListener('touchstart', (e)=>{ e.preventDefault(); joy.active=true; });
stickWrap.addEventListener('touchend', (e)=>{ e.preventDefault(); joy.active=false; joy.dx=joy.dy=0; stick.style.transform='translate(0px,0px)'; });
stickWrap.addEventListener('touchmove', (e)=>{ e.preventDefault(); const t=e.touches[0]; joy.dx = clamp(t.clientX - joy.cx, -50, 50); joy.dy = clamp(t.clientY - joy.cy, -50, 50); stick.style.transform = `translate(${joy.dx}px, ${joy.dy}px)`; });

// Mouse drag support for joystick on desktop
let mouseDownOnStick = false;
stickWrap.addEventListener('mousedown', (e)=>{ mouseDownOnStick = true; joy.active = true; });
window.addEventListener('mouseup', ()=>{ mouseDownOnStick = false; joy.active = false; joy.dx = joy.dy = 0; stick.style.transform = 'translate(0px,0px)'; });
window.addEventListener('mousemove', (e)=>{ if(!mouseDownOnStick) return; joy.dx = clamp(e.clientX - joy.cx, -50, 50); joy.dy = clamp(e.clientY - joy.cy, -50, 50); stick.style.transform = `translate(${joy.dx}px, ${joy.dy}px)`; });

// Keyboard
let keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

// Skin UI
const colorPicker = document.getElementById('colorPicker');
const thicknessInput = document.getElementById('thickness');
colorPicker.addEventListener('input', ()=>{ const hex=colorPicker.value; const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16); player.color=[r,g,b]; });
thicknessInput.addEventListener('input', ()=>{ player.thickness = parseInt(thicknessInput.value); });

// Utilities
function distance2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy }
function aimTowards(s,tx,ty){ s.dir = Math.atan2(ty - s.y, tx - s.x); }

// Bot AI
function botAI(s){ if(s.respawnTimer>0) return; let target=null, best=Infinity; for(const f of foods){ const d=(f.x-s.x)*(f.x-s.x)+(f.y-s.y)*(f.y-s.y); if(d<best){best=d;target=f;} } for(const other of snakes){ if(other===s || !other.alive) continue; const d=(other.x-s.x)*(other.x-s.x)+(other.y-s.y)*(other.y-s.y); if(d<40000 && d < best*0.6){ best=d; target=other; } } if(target) aimTowards(s,target.x,target.y); }

// Collisions
function checkCollisions(){
  for(const s of snakes){ if(!s.alive) continue;
    for(const other of snakes){ if(other === s) continue;
      if(!other.alive) continue;
      for(let i=0;i<other.tail.length;i+=2){ const p = other.tail[i]; const dx = s.x - p.x, dy = s.y - p.y; const thresh = (player.thickness || 14) ** 2; if(dx*dx + dy*dy < thresh){
          // other gets points for kill
          other.score = (other.score||0) + 100; other.len += 10; other.thickness = Math.min((other.thickness||14)+1,50);
          // if victim is player => reset leaderboard and player score
          if(s === player){ localStorage.removeItem('snake_leader'); player.score = 0; document.getElementById('scoreUI').textContent='Skor: 0'; }
          // spawn explosion and respawn victim
          spawnExplosion(s.x,s.y,other.color,40);
          s.alive = false; s.respawnTimer = 90; s.tail = []; s.len = 40; s.x = rand(-WORLD_SIZE/2,WORLD_SIZE/2); s.y = rand(-WORLD_SIZE/2,WORLD_SIZE/2); s.speed = 2.6;
          // record kill for player if killer is player
          if(other === player){ player.score = (player.score||0) + 100; document.getElementById('scoreUI').textContent = 'Skor: '+player.score; }
          break;
        }
      }
    }
  }
}

// Update snake
function updateSnake(s,dt){
  if(!s.alive){ s.respawnTimer -= 1; if(s.respawnTimer<=0) s.alive=true; return; }

  if(s === player){
    if(joy.active){
      if(joy.dx !== 0 || joy.dy !== 0){
        // invert dy because screen y increases downward
        player.dir = Math.atan2(joy.dy, joy.dx);
      }
    } else if(pointer.active){
      const worldX = cam.x + pointer.x; const worldY = cam.y + pointer.y; aimTowards(player, worldX, worldY);
    }
    if(keys['arrowleft']||keys['a']) player.dir -= 0.35; if(keys['arrowright']||keys['d']) player.dir += 0.35;
    player.speed = (pointer.active||keys['arrowup']||keys['w']) ? 3.8 : 2.6;
  } else {
    botAI(s);
  }

  // movement
  s.x += Math.cos(s.dir) * s.speed * dt * 60;
  s.y += Math.sin(s.dir) * s.speed * dt * 60;

  // wrap
  if(s.x < -WORLD_SIZE/2) s.x = WORLD_SIZE/2; if(s.x > WORLD_SIZE/2) s.x = -WORLD_SIZE/2;
  if(s.y < -WORLD_SIZE/2) s.y = WORLD_SIZE/2; if(s.y > WORLD_SIZE/2) s.y = -WORLD_SIZE/2;

  s.tail.push({x:s.x,y:s.y}); while(s.tail.length > s.len) s.tail.shift();

  // eat food
  for(let i=foods.length-1;i>=0;i--){ const f = foods[i]; const dx = f.x-s.x, dy = f.y-s.y; if(dx*dx+dy*dy < (10*10)){
      foods.splice(i,1);
      s.len += 6;
      s.score = (s.score||0) + 1;
      if(s===player) document.getElementById('scoreUI').textContent = 'Skor: '+player.score;
      s.thickness = Math.min((s.thickness||14) + 0.3, 40);
      spawnFood(); }}
}

// Draw
function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#03121b'; ctx.fillRect(0,0,W,H);

  // foods
  for(const f of foods){ const sx = f.x - cam.x, sy = f.y - cam.y; const [r,g,b] = f.color; const grad = ctx.createRadialGradient(sx,sy,2,sx,sy,20); grad.addColorStop(0, `rgba(${r},${g},${b},0.9)`); grad.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(sx,sy,18,0,Math.PI*2); ctx.fill(); ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.beginPath(); ctx.arc(sx,sy,f.r,0,Math.PI*2); ctx.fill(); }

  // snakes
  for(const s of snakes){ if(!s.alive) continue; ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle = `rgb(${s.color[0]},${s.color[1]},${s.color[2]})`; ctx.lineWidth = s.thickness || 14; ctx.beginPath(); for(let i=0;i<s.tail.length;i++){ const p = s.tail[i]; const sx = p.x - cam.x, sy = p.y - cam.y; if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy); } ctx.stroke(); const hx = s.x - cam.x, hy = s.y - cam.y; ctx.fillStyle = `rgb(${s.color[0]},${s.color[1]},${s.color[2]})`; ctx.beginPath(); ctx.ellipse(hx,hy,(s.thickness||14)/1.2,(s.thickness||14)/1,0,0,Math.PI*2); ctx.fill(); const eyeOffset=6; const ex=Math.cos(s.dir)*eyeOffset, ey=Math.sin(s.dir)*eyeOffset; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(hx+ex-4,hy+ey-3,3,3,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(hx+ex-4,hy+ey+3,3,3,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(hx+ex-4,hy+ey-3,1.3,1.3,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(hx+ex-4,hy+ey+3,1.3,1.3,0,0,Math.PI*2); ctx.fill(); }

  // particles
  for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.t += 1/60; if(p.t>p.life){ particles.splice(i,1); continue; } const alpha = 1 - p.t/p.life; ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${alpha})`; ctx.beginPath(); const sx = p.x - cam.x, sy = p.y - cam.y; ctx.arc(sx + p.vx*(p.t), sy + p.vy*(p.t), 3,0,Math.PI*2); ctx.fill(); }

  // HUD
  ctx.fillStyle='#fff'; ctx.font='18px Inter'; ctx.fillText('Skor: '+(player.score||0), 18, 28);
}

// Mini map
function drawMini(){ mctx.clearRect(0,0,160,160); mctx.fillStyle='#001522'; mctx.beginPath(); mctx.arc(80,80,80,0,Math.PI*2); mctx.fill(); const scale = 160 / WORLD_SIZE; for(const f of foods){ mctx.fillStyle = `rgb(${f.color[0]},${f.color[1]},${f.color[2]})`; mctx.fillRect((f.x+WORLD_SIZE/2)*scale-1, (f.y+WORLD_SIZE/2)*scale-1, 3,3); } for(const s of snakes){ mctx.fillStyle = `rgb(${s.color[0]},${s.color[1]},${s.color[2]})`; mctx.fillRect((s.x+WORLD_SIZE/2)*scale-2, (s.y+WORLD_SIZE/2)*scale-2, 4,4); } mctx.fillStyle='#fff'; mctx.fillRect((player.x+WORLD_SIZE/2)*scale-3, (player.y+WORLD_SIZE/2)*scale-3,6,6); }

// Main loop
let last = performance.now();
function tick(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  updateCamera();
  for(const s of snakes) updateSnake(s, dt);
  checkCollisions();
  draw();
  drawMini();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// Buttons
const btnNew = document.getElementById('btnNew');
btnNew.addEventListener('click', ()=>{
  // reset
  player = makeSnake(false); player.color=[52,211,153]; player.thickness=14; player.score=0; player.name='Esma';
  snakes=[player];
  for(let i=0;i<8;i++) snakes.push(makeSnake(true));
  foods=[]; for(let i=0;i<120;i++) spawnFood();
  document.getElementById('scoreUI').textContent = 'Skor: 0';
});

const btnPause = document.getElementById('btnPause');
btnPause.addEventListener('click', ()=>{ location.reload(); });

// Pointer events
window.addEventListener('pointermove', e=>{ pointer.x=e.clientX; pointer.y=e.clientY; });
window.addEventListener('pointerdown', ()=>pointer.active=true); window.addEventListener('pointerup', ()=>pointer.active=false);

// Initialize UI
if(document.getElementById('scoreUI')) document.getElementById('scoreUI').textContent = 'Skor: 0';

</script>
</body>
</html>
